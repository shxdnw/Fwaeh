<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Arrow Simulation</title>
    <style>
        /* ... (keep previous styles) ... */
    </style>
</head>
<body>
    <!-- Keep previous HTML structure -->
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pixelsPerMeter = 40; // Scaling factor
        let lastTime = 0;

        // Physics constants
        const AIR_DENSITY = 1.225; // kg/mÂ³
        const ARROW_DIAMETER = 0.05; // meters
        const DRAG_COEFFICIENT = 0.5;

        // Set canvas size
        function resizeCanvas() {
            canvas.width = gameContainer.offsetWidth;
            canvas.height = gameContainer.offsetHeight;
            groundY = canvas.height * 0.8;
        }

        let groundY;
        const gameContainer = document.getElementById('game-container');
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Simulation state
        let arrow = {
            x: 50,
            y: groundY - 1,
            vx: 0,
            vy: 0,
            trail: [],
            flying: false,
            startTime: 0,
            maxSpeed: 0,
            launched: false
        };

        // Control elements (keep previous code)

        function drawEnvironment() {
            // Ground
            ctx.fillStyle = '#4a752c';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            // Target (keep previous code)
        }

        function drawPreview() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEnvironment();
            
            const angle = (controls.angle.value * Math.PI) / 180;
            const velocity = controls.velocity.value;
            const length = velocity * pixelsPerMeter / 15;
            
            // Preview arrow drawing (keep previous code)
        }

        function launch() {
            if (arrow.flying) return;
            
            const angle = (controls.angle.value * Math.PI) / 180;
            const velocity = controls.velocity.value;
            
            arrow.vx = velocity * Math.cos(angle) * pixelsPerMeter;
            arrow.vy = -velocity * Math.sin(angle) * pixelsPerMeter;
            arrow.flying = true;
            arrow.launched = true;
            arrow.startTime = Date.now();
            arrow.maxSpeed = 0;
            arrow.trail = [];
            
            lastTime = Date.now();
            animate();
        }

        function animate() {
            if (!arrow.flying) return;

            const currentTime = Date.now();
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Physics calculations
            const gravity = parseFloat(controls.gravity.value) * pixelsPerMeter;
            const wind = parseFloat(controls.wind.value) * pixelsPerMeter;
            
            // Air resistance calculation
            const speed = Math.hypot(arrow.vx, arrow.vy) / pixelsPerMeter;
            const frontalArea = Math.PI * (ARROW_DIAMETER/2)**2;
            const dragForce = 0.5 * AIR_DENSITY * speed**2 * DRAG_COEFFICIENT * frontalArea;
            
            // Acceleration components
            const ax = (wind - (dragForce * arrow.vx / speed)) / pixelsPerMeter;
            const ay = (gravity - (dragForce * arrow.vy / speed)) / pixelsPerMeter;

            // Semi-implicit Euler integration
            arrow.vx += ax * dt;
            arrow.vy += ay * dt;
            arrow.x += arrow.vx * dt;
            arrow.y += arrow.vy * dt;

            // Track maximum speed
            const currentSpeed = Math.hypot(arrow.vx, arrow.vy);
            arrow.maxSpeed = Math.max(arrow.maxSpeed, currentSpeed);

            // Store trail (every 50ms)
            if (Date.now() - arrow.startTime % 50 < dt*1000) {
                arrow.trail.push({x: arrow.x, y: arrow.y});
                if (arrow.trail.length > 30) arrow.trail.shift();
            }

            // Collision detection
            if (arrow.y >= groundY - 1) {
                arrow.y = groundY - 1;
                arrow.flying = false;
                updateStats();
                drawFrame();
                return;
            }

            // Boundary checks
            if (arrow.x > canvas.width + 100 || arrow.x < -100 || arrow.y < -100) {
                arrow.flying = false;
                updateStats();
                drawFrame();
                return;
            }

            drawFrame();
            requestAnimationFrame(animate);
        }

        function drawFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEnvironment();

            // Draw trail
            arrow.trail.forEach((pos, i) => {
                const alpha = i / arrow.trail.length;
                ctx.fillStyle = `rgba(139,69,19,${alpha})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw arrow
            const angle = Math.atan2(-arrow.vy, arrow.vx);
            ctx.save();
            ctx.translate(arrow.x, arrow.y);
            ctx.rotate(angle);
            
            // Arrow body
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(30, 0);
            ctx.stroke();
            
            // Arrowhead
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.moveTo(30, 0);
            ctx.lineTo(25, -5);
            ctx.lineTo(25, 5);
            ctx.fill();
            
            ctx.restore();

            // Check target hit
            if (checkTargetHit()) {
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(canvas.width - 100, groundY - 20, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function checkTargetHit() {
            const targetX = canvas.width - 100;
            const targetY = groundY - 20;
            const distance = Math.hypot(arrow.x - targetX, arrow.y - targetY);
            return distance < 30;
        }

        function updateStats() {
            const time = ((Date.now() - arrow.startTime) / 1000).toFixed(1);
            const distance = ((arrow.x - 50) / pixelsPerMeter).toFixed(1);
            const maxSpeed = (arrow.maxSpeed / pixelsPerMeter).toFixed(1);
            document.getElementById('stats').textContent = 
                `Distance: ${distance}m | Time: ${time}s | Max Speed: ${maxSpeed}m/s`;
        }

        function reset() {
            arrow = {
                x: 50,
                y: groundY - 1,
                vx: 0,
                vy: 0,
                trail: [],
                flying: false,
                startTime: 0,
                maxSpeed: 0,
                launched: false
            };
            document.getElementById('stats').textContent = 'Distance: 0m | Time: 0s | Max Speed: 0m/s';
            drawPreview();
        }

        // Initial draw
        drawPreview();
    </script>
</body>
</html>